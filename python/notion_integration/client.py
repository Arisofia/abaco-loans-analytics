import _ast
import _sitebuiltinslient
import _typeshed--------
import re-ready module for secure Notion API access and data extraction.
import sys
import types
import os
import requests
from requests.adapters import HTTPAdapter, Retry
from _collections_abc import dict_items, dict_keys, dict_values
from _typeshed import (
    AnnotationForm, Dict, List, Optional
    ConvertibleToFloat,
    ConvertibleToInt,
    FileDescriptorOrPath,ers import HTTPAdapter
    OpenBinaryMode,port Retry
    OpenBinaryModeReading,
    OpenBinaryModeUpdating,(__name__)
    OpenBinaryModeWriting,
    OpenTextMode,
    ReadableBuffer,(self, token_env: Optional[str] = None, version_env: Optional[str] = None):
    SupportsAdd,= token_env or "NOTION_META_TOKEN"
    SupportsAiter,y = version_env or "NOTION_VERSION"
    SupportsAnext,= os.getenv(token_key)
    SupportsDivMod,on = os.getenv(version_key, "2022-06-28")
    SupportsFlush,lf.token:
    SupportsIter,r(f"Environment variable {token_key} is not set")
    SupportsKeysAndGetItem,
    SupportsLenAndGetItem,ion = requests.Session()
    SupportsNext, Retry(total=3, backoff_factor=1, status_forcelist=[429, 500, 502, 503, 504])
    SupportsRAdd,.mount("https://", HTTPAdapter(max_retries=retries))
    SupportsRDivMod,
    SupportsRichComparison, database_id: str) -> List[Dict[str, Any]]:
    SupportsRichComparisonT,tps://api.notion.com/v1/databases/{database_id}/query"
    SupportsWrite,       headers = {
)
from collections.abc import Awaitable, Callable, Iterable, Iterator, MutableSet, Reversible, Set as AbstractSet, Sized
from io import BufferedRandom, BufferedReader, BufferedWriter, FileIO, TextIOWrapperpe": "application/json",
from os import PathLike
from types import CellType, CodeType, GenericAlias, TracebackType        results = []

# mypy crashes if any of {ByteString, Sequence, MutableSequence, Mapping, MutableMapping}
# are imported from collections.abc in builtins.pyi
from typing import (  # noqa: Y022,UP035     body: dict[str, object] = {"start_cursor": start_cursor} if start_cursor else {}
    IO,    response = self.session.post(url, headers=headers, json=body, timeout=30)
    Any,esponse.raise_for_status()
    BinaryIO,ata = response.json()
    ClassVar,results.extend(data.get("results", []))
    Generic,has_more = data.get("has_more", False)
    Mapping,ursor = data.get("next_cursor")
    MutableMapping,ts
    MutableSequence,    Protocol,    Sequence,    SupportsAbs,    SupportsBytes,    SupportsComplex,    SupportsFloat,    SupportsIndex,    TypeVar,    final,    overload,    type_check_only,)# we can't import `Literal` from typing or mypy crashes: see #11247from typing_extensions import (  # noqa: Y023    Concatenate,    Literal,    LiteralString,    ParamSpec,    Self,    TypeAlias,    TypeGuard,    TypeIs,    TypeVarTuple,    deprecated,    disjoint_base,)if sys.version_info >= (3, 14):    from _typeshed import AnnotateFunc_T = TypeVar("_T")_I = TypeVar("_I", default=int)_T_co = TypeVar("_T_co", covariant=True)_T_contra = TypeVar("_T_contra", contravariant=True)_R_co = TypeVar("_R_co", covariant=True)_KT = TypeVar("_KT")_VT = TypeVar("_VT")_S = TypeVar("_S")_T1 = TypeVar("_T1")_T2 = TypeVar("_T2")_T3 = TypeVar("_T3")_T4 = TypeVar("_T4")_T5 = TypeVar("_T5")_SupportsNextT_co = TypeVar("_SupportsNextT_co", bound=SupportsNext[Any], covariant=True)_SupportsAnextT_co = TypeVar("_SupportsAnextT_co", bound=SupportsAnext[Any], covariant=True)_AwaitableT = TypeVar("_AwaitableT", bound=Awaitable[Any])_AwaitableT_co = TypeVar("_AwaitableT_co", bound=Awaitable[Any], covariant=True)_P = ParamSpec("_P")# Type variables for slice_StartT_co = TypeVar("_StartT_co", covariant=True, default=Any)  # slice -> slice[Any, Any, Any]_StopT_co = TypeVar("_StopT_co", covariant=True, default=_StartT_co)  #  slice[A] -> slice[A, A, A]# NOTE: step could differ from start and stop, (e.g. datetime/timedelta)l#   the default (start|stop) is chosen to cater to the most common case of int/index slices.# FIXME: https://github.com/python/typing/issues/213 (replace step=start|stop with step=start&stop)_StepT_co = TypeVar("_StepT_co", covariant=True, default=_StartT_co | _StopT_co)  #  slice[A,B] -> slice[A, B, A|B]@disjoint_baseclass object:    __doc__: str | None    __dict__: dict[str, Any]    __module__: str    __annotations__: dict[str, Any]    @property    def __class__(self) -> type[Self]: ...    @__class__.setter    def __class__(self, type: type[Self], /) -> None: ...    def __init__(self) -> None: ...    def __new__(cls) -> Self: ...    # N.B. `object.__setattr__` and `object.__delattr__` are heavily special-cased by type checkers.    # Overriding them in subclasses has different semantics, even if the override has an identical signature.    def __setattr__(self, name: str, value: Any, /) -> None: ...    def __delattr__(self, name: str, /) -> None: ...    def __eq__(self, value: object, /) -> bool: ...    def __ne__(self, value: object, /) -> bool: ...    def __str__(self) -> str: ...  # noqa: Y029    def __repr__(self) -> str: ...  # noqa: Y029    def __hash__(self) -> int: ...    def __format__(self, format_spec: str, /) -> str: ...    def __getattribute__(self, name: str, /) -> Any: ...    def __sizeof__(self) -> int: ...    # return type of pickle methods is rather hard to express in the current type system    # see #6661 and https://docs.python.org/3/library/pickle.html#object.__reduce__    def __reduce__(self) -> str | tuple[Any, ...]: ...    def __reduce_ex__(self, protocol: SupportsIndex, /) -> str | tuple[Any, ...]: ...    if sys.version_info >= (3, 11):        def __getstate__(self) -> object: ...    def __dir__(self) -> Iterable[str]: ...    def __init_subclass__(cls) -> None: ...    @classmethod    def __subclasshook__(cls, subclass: type, /) -> bool: ...@disjoint_baseclass staticmethod(Generic[_P, _R_co]):    @property    def __func__(self) -> Callable[_P, _R_co]: ...    @property    def __isabstractmethod__(self) -> bool: ...    def __init__(self, f: Callable[_P, _R_co], /) -> None: ...    @overload    def __get__(self, instance: None, owner: type, /) -> Callable[_P, _R_co]: ...    @overload    def __get__(self, instance: _T, owner: type[_T] | None = None, /) -> Callable[_P, _R_co]: ...    if sys.version_info >= (3, 10):        __name__: str        __qualname__: str        @property        def __wrapped__(self) -> Callable[_P, _R_co]: ...        def __call__(self, *args: _P.args, **kwargs: _P.kwargs) -> _R_co: ...    if sys.version_info >= (3, 14):        def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...        __annotate__: AnnotateFunc | None@disjoint_baseclass classmethod(Generic[_T, _P, _R_co]):    @property    def __func__(self) -> Callable[Concatenate[type[_T], _P], _R_co]: ...    @property    def __isabstractmethod__(self) -> bool: ...    def __init__(self, f: Callable[Concatenate[type[_T], _P], _R_co], /) -> None: ...    @overload    def __get__(self, instance: _T, owner: type[_T] | None = None, /) -> Callable[_P, _R_co]: ...    @overload    def __get__(self, instance: None, owner: type[_T], /) -> Callable[_P, _R_co]: ...    if sys.version_info >= (3, 10):        __name__: str        __qualname__: str        @property        def __wrapped__(self) -> Callable[Concatenate[type[_T], _P], _R_co]: ...    if sys.version_info >= (3, 14):        def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...        __annotate__: AnnotateFunc | None@disjoint_baseclass type:    # object.__base__ is None. Otherwise, it would be a type.    @property    def __base__(self) -> type | None: ...    __bases__: tuple[type, ...]    @property    def __basicsize__(self) -> int: ...    @property    def __dict__(self) -> types.MappingProxyType[str, Any]: ...  # type: ignore[override]    @property    def __dictoffset__(self) -> int: ...    @property    def __flags__(self) -> int: ...    @property    def __itemsize__(self) -> int: ...    __module__: str    @property    def __mro__(self) -> tuple[type, ...]: ...    __name__: str    __qualname__: str    @property    def __text_signature__(self) -> str | None: ...    @property    def __weakrefoffset__(self) -> int: ...    @overload    def __init__(self, o: object, /) -> None: ...    @overload    def __init__(self, name: str, bases: tuple[type, ...], dict: dict[str, Any], /, **kwds: Any) -> None: ...    @overload    def __new__(cls, o: object, /) -> type: ...    @overload    def __new__(        cls: type[_typeshed.Self], name: str, bases: tuple[type, ...], namespace: dict[str, Any], /, **kwds: Any    ) -> _typeshed.Self: ...    def __call__(self, *args: Any, **kwds: Any) -> Any: ...    def __subclasses__(self: _typeshed.Self) -> list[_typeshed.Self]: ...    # Note: the documentation doesn't specify what the return type is, the standard    # implementation seems to be returning a list.    def mro(self) -> list[type]: ...    def __instancecheck__(self, instance: Any, /) -> bool: ...    def __subclasscheck__(self, subclass: type, /) -> bool: ...    @classmethod    def __prepare__(metacls, name: str, bases: tuple[type, ...], /, **kwds: Any) -> MutableMapping[str, object]: ...    if sys.version_info >= (3, 10):        # `int | str` produces an instance of `UnionType`, but `int | int` produces an instance of `type`,        # and `abc.ABC | abc.ABC` produces an instance of `abc.ABCMeta`.        def __or__(self: _typeshed.Self, value: Any, /) -> types.UnionType | _typeshed.Self: ...        def __ror__(self: _typeshed.Self, value: Any, /) -> types.UnionType | _typeshed.Self: ...    if sys.version_info >= (3, 12):        __type_params__: tuple[TypeVar | ParamSpec | TypeVarTuple, ...]    __annotations__: dict[str, AnnotationForm]    if sys.version_info >= (3, 14):        __annotate__: AnnotateFunc | None@disjoint_baseclass super:    @overload    def __init__(self, t: Any, obj: Any, /) -> None: ...    @overload    def __init__(self, t: Any, /) -> None: ...    @overload    def __init__(self) -> None: ..._PositiveInteger: TypeAlias = Literal[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]_NegativeInteger: TypeAlias = Literal[-1, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, -12, -13, -14, -15, -16, -17, -18, -19, -20]_LiteralInteger = _PositiveInteger | _NegativeInteger | Literal[0]  # noqa: Y026  # TODO: Use TypeAlias once mypy bugs are fixed@disjoint_baseclass int:    @overload    def __new__(cls, x: ConvertibleToInt = 0, /) -> Self: ...    @overload    def __new__(cls, x: str | bytes | bytearray, /, base: SupportsIndex) -> Self: ...    def as_integer_ratio(self) -> tuple[int, Literal[1]]: ...    @property    def real(self) -> int: ...    @property    def imag(self) -> Literal[0]: ...    @property    def numerator(self) -> int: ...    @property    def denominator(self) -> Literal[1]: ...    def conjugate(self) -> int: ...    def bit_length(self) -> int: ...    if sys.version_info >= (3, 10):        def bit_count(self) -> int: ...    if sys.version_info >= (3, 11):        def to_bytes(            self, length: SupportsIndex = 1, byteorder: Literal["little", "big"] = "big", *, signed: bool = False        ) -> bytes: ...        @classmethod        def from_bytes(            cls,            bytes: Iterable[SupportsIndex] | SupportsBytes | ReadableBuffer,            byteorder: Literal["little", "big"] = "big",            *,            signed: bool = False,        ) -> Self: ...    else:        def to_bytes(self, length: SupportsIndex, byteorder: Literal["little", "big"], *, signed: bool = False) -> bytes: ...        @classmethod        def from_bytes(            cls,            bytes: Iterable[SupportsIndex] | SupportsBytes | ReadableBuffer,            byteorder: Literal["little", "big"],            *,            signed: bool = False,        ) -> Self: ...    if sys.version_info >= (3, 12):        def is_integer(self) -> Literal[True]: ...    def __add__(self, value: int, /) -> int: ...    def __sub__(self, value: int, /) -> int: ...    def __mul__(self, value: int, /) -> int: ...    def __floordiv__(self, value: int, /) -> int: ...    def __truediv__(self, value: int, /) -> float: ...    def __mod__(self, value: int, /) -> int: ...    def __divmod__(self, value: int, /) -> tuple[int, int]: ...    def __radd__(self, value: int, /) -> int: ...    def __rsub__(self, value: int, /) -> int: ...    def __rmul__(self, value: int, /) -> int: ...    def __rfloordiv__(self, value: int, /) -> int: ...    def __rtruediv__(self, value: int, /) -> float: ...    def __rmod__(self, value: int, /) -> int: ...    def __rdivmod__(self, value: int, /) -> tuple[int, int]: ...    @overload    def __pow__(self, x: Literal[0], /) -> Literal[1]: ...    @overload    def __pow__(self, value: Literal[0], mod: None, /) -> Literal[1]: ...    @overload    def __pow__(self, value: _PositiveInteger, mod: None = None, /) -> int: ...    @overload    def __pow__(self, value: _NegativeInteger, mod: None = None, /) -> float: ...    # positive __value -> int; negative __value -> float    # return type must be Any as `int | float` causes too many false-positive errors    @overload    def __pow__(self, value: int, mod: None = None, /) -> Any: ...    @overload    def __pow__(self, value: int, mod: int, /) -> int: ...    def __rpow__(self, value: int, mod: int | None = None, /) -> Any: ...    def __and__(self, value: int, /) -> int: ...    def __or__(self, value: int, /) -> int: ...    def __xor__(self, value: int, /) -> int: ...    def __lshift__(self, value: int, /) -> int: ...    def __rshift__(self, value: int, /) -> int: ...    def __rand__(self, value: int, /) -> int: ...    def __ror__(self, value: int, /) -> int: ...    def __rxor__(self, value: int, /) -> int: ...    def __rlshift__(self, value: int, /) -> int: ...    def __rrshift__(self, value: int, /) -> int: ...    def __neg__(self) -> int: ...    def __pos__(self) -> int: ...    def __invert__(self) -> int: ...    def __trunc__(self) -> int: ...    def __ceil__(self) -> int: ...    def __floor__(self) -> int: ...    if sys.version_info >= (3, 14):        def __round__(self, ndigits: SupportsIndex | None = None, /) -> int: ...    else:        def __round__(self, ndigits: SupportsIndex = ..., /) -> int: ...    def __getnewargs__(self) -> tuple[int]: ...    def __eq__(self, value: object, /) -> bool: ...    def __ne__(self, value: object, /) -> bool: ...    def __lt__(self, value: int, /) -> bool: ...    def __le__(self, value: int, /) -> bool: ...    def __gt__(self, value: int, /) -> bool: ...    def __ge__(self, value: int, /) -> bool: ...    def __float__(self) -> float: ...    def __int__(self) -> int: ...    def __abs__(self) -> int: ...    def __hash__(self) -> int: ...    def __bool__(self) -> bool: ...    def __index__(self) -> int: ...    def __format__(self, format_spec: str, /) -> str: ...@disjoint_baseclass float:    def __new__(cls, x: ConvertibleToFloat = 0, /) -> Self: ...    def as_integer_ratio(self) -> tuple[int, int]: ...    def hex(self) -> str: ...    def is_integer(self) -> bool: ...    @classmethod    def fromhex(cls, string: str, /) -> Self: ...    @property    def real(self) -> float: ...    @property    def imag(self) -> float: ...    def conjugate(self) -> float: ...    def __add__(self, value: float, /) -> float: ...    def __sub__(self, value: float, /) -> float: ...    def __mul__(self, value: float, /) -> float: ...    def __floordiv__(self, value: float, /) -> float: ...    def __truediv__(self, value: float, /) -> float: ...    def __mod__(self, value: float, /) -> float: ...    def __divmod__(self, value: float, /) -> tuple[float, float]: ...    @overload    def __pow__(self, value: int, mod: None = None, /) -> float: ...    # positive __value -> float; negative __value -> complex    # return type must be Any as `float | complex` causes too many false-positive errors    @overload    def __pow__(self, value: float, mod: None = None, /) -> Any: ...    def __radd__(self, value: float, /) -> float: ...    def __rsub__(self, value: float, /) -> float: ...    def __rmul__(self, value: float, /) -> float: ...    def __rfloordiv__(self, value: float, /) -> float: ...    def __rtruediv__(self, value: float, /) -> float: ...    def __rmod__(self, value: float, /) -> float: ...    def __rdivmod__(self, value: float, /) -> tuple[float, float]: ...    @overload    def __rpow__(self, value: _PositiveInteger, mod: None = None, /) -> float: ...    @overload    def __rpow__(self, value: _NegativeInteger, mod: None = None, /) -> complex: ...    # Returning `complex` for the general case gives too many false-positive errors.    @overload    def __rpow__(self, value: float, mod: None = None, /) -> Any: ...    def __getnewargs__(self) -> tuple[float]: ...    def __trunc__(self) -> int: ...    def __ceil__(self) -> int: ...    def __floor__(self) -> int: ...    @overload    def __round__(self, ndigits: None = None, /) -> int: ...    @overload    def __round__(self, ndigits: SupportsIndex, /) -> float: ...    def __eq__(self, value: object, /) -> bool: ...    def __ne__(self, value: object, /) -> bool: ...    def __lt__(self, value: float, /) -> bool: ...    def __le__(self, value: float, /) -> bool: ...    def __gt__(self, value: float, /) -> bool: ...    def __ge__(self, value: float, /) -> bool: ...    def __neg__(self) -> float: ...    def __pos__(self) -> float: ...    def __int__(self) -> int: ...    def __float__(self) -> float: ...    def __abs__(self) -> float: ...    def __hash__(self) -> int: ...    def __bool__(self) -> bool: ...    def __format__(self, format_spec: str, /) -> str: ...    if sys.version_info >= (3, 14):        @classmethod        def from_number(cls, number: float | SupportsIndex | SupportsFloat, /) -> Self: ...@disjoint_baseclass complex:    # Python doesn't currently accept SupportsComplex for the second argument    @overload    def __new__(        cls,        real: complex | SupportsComplex | SupportsFloat | SupportsIndex = 0,        imag: complex | SupportsFloat | SupportsIndex = 0,    ) -> Self: ...    @overload    def __new__(cls, real: str | SupportsComplex | SupportsFloat | SupportsIndex | complex) -> Self: ...    @property    def real(self) -> float: ...    @property    def imag(self) -> float: ...    def conjugate(self) -> complex: ...    def __add__(self, value: complex, /) -> complex: ...    def __sub__(self, value: complex, /) -> complex: ...    def __mul__(self, value: complex, /) -> complex: ...    def __pow__(self, value: complex, mod: None = None, /) -> complex: ...    def __truediv__(self, value: complex, /) -> complex: ...    def __radd__(self, value: complex, /) -> complex: ...    def __rsub__(self, value: complex, /) -> complex: ...    def __rmul__(self, value: complex, /) -> complex: ...    def __rpow__(self, value: complex, mod: None = None, /) -> complex: ...    def __rtruediv__(self, value: complex, /) -> complex: ...    def __eq__(self, value: object, /) -> bool: ...    def __ne__(self, value: object, /) -> bool: ...    def __neg__(self) -> complex: ...    def __pos__(self) -> complex: ...    def __abs__(self) -> float: ...    def __hash__(self) -> int: ...    def __bool__(self) -> bool: ...    def __format__(self, format_spec: str, /) -> str: ...    if sys.version_info >= (3, 11):        def __complex__(self) -> complex: ...    if sys.version_info >= (3, 14):        @classmethod        def from_number(cls, number: complex | SupportsComplex | SupportsFloat | SupportsIndex, /) -> Self: ...@type_check_onlyclass _FormatMapMapping(Protocol):    def __getitem__(self, key: str, /) -> Any: ...@type_check_onlyclass _TranslateTable(Protocol):    def __getitem__(self, key: int, /) -> str | int | None: ...@disjoint_baseclass str(Sequence[str]):    @overload    def __new__(cls, object: object = "") -> Self: ...    @overload    def __new__(cls, object: ReadableBuffer, encoding: str = "utf-8", errors: str = "strict") -> Self: ...    @overload    def capitalize(self: LiteralString) -> LiteralString: ...    @overload    def capitalize(self) -> str: ...  # type: ignore[misc]    @overload    def casefold(self: LiteralString) -> LiteralString: ...    @overload    def casefold(self) -> str: ...  # type: ignore[misc]    @overload    def center(self: LiteralString, width: SupportsIndex, fillchar: LiteralString = " ", /) -> LiteralString: ...    @overload    def center(self, width: SupportsIndex, fillchar: str = " ", /) -> str: ...  # type: ignore[misc]    def count(self, sub: str, start: SupportsIndex | None = None, end: SupportsIndex | None = None, /) -> int: ...    def encode(self, encoding: str = "utf-8", errors: str = "strict") -> bytes: ...    def endswith(        self, suffix: str | tuple[str, ...], start: SupportsIndex | None = None, end: SupportsIndex | None = None, /    ) -> bool: ...    @overload    def expandtabs(self: LiteralString, tabsize: SupportsIndex = 8) -> LiteralString: ...    @overload    def expandtabs(self, tabsize: SupportsIndex = 8) -> str: ...  # type: ignore[misc]    def find(self, sub: str, start: SupportsIndex | None = None, end: SupportsIndex | None = None, /) -> int: ...    @overload    def format(self: LiteralString, *args: LiteralString, **kwargs: LiteralString) -> LiteralString: ...    @overload    def format(self, *args: object, **kwargs: object) -> str: ...    def format_map(self, mapping: _FormatMapMapping, /) -> str: ...    def index(self, sub: str, start: SupportsIndex | None = None, end: SupportsIndex | None = None, /) -> int: ...    def isalnum(self) -> bool: ...    def isalpha(self) -> bool: ...    def isascii(self) -> bool: ...    def isdecimal(self) -> bool: ...    def isdigit(self) -> bool: ...    def isidentifier(self) -> bool: ...    def islower(self) -> bool: ...    def isnumeric(self) -> bool: ...    def isprintable(self) -> bool: ...    def isspace(self) -> bool: ...    def istitle(self) -> bool: ...    def isupper(self) -> bool: ...    @overload    def join(self: LiteralString, iterable: Iterable[LiteralString], /) -> LiteralString: ...    @overload    def join(self, iterable: Iterable[str], /) -> str: ...  # type: ignore[misc]    @overload    def ljust(self: LiteralString, width: SupportsIndex, fillchar: LiteralString = " ", /) -> LiteralString: ...    @overload    def ljust(self, width: SupportsIndex, fillchar: str = " ", /) -> str: ...  # type: ignore[misc]    @overload    def lower(self: LiteralString) -> LiteralString: ...    @overload    def lower(self) -> str: ...  # type: ignore[misc]    @overload    def lstrip(self: LiteralString, chars: LiteralString | None = None, /) -> LiteralString: ...    @overload    def lstrip(self, chars: str | None = None, /) -> str: ...  # type: ignore[misc]    @overload    def partition(self: LiteralString, sep: LiteralString, /) -> tuple[LiteralString, LiteralString, LiteralString]: ...    @overload    def partition(self, sep: str, /) -> tuple[str, str, str]: ...  # type: ignore[misc]    if sys.version_info >= (3, 13):        @overload        def replace(            self: LiteralString, old: LiteralString, new: LiteralString, /, count: SupportsIndex = -1        ) -> LiteralString: ...        @overload        def replace(self, old: str, new: str, /, count: SupportsIndex = -1) -> str: ...  # type: ignore[misc]    else:        @overload        def replace(            self: LiteralString, old: LiteralString, new: LiteralString, count: SupportsIndex = -1, /        ) -> LiteralString: ...        @overload        def replace(self, old: str, new: str, count: SupportsIndex = -1, /) -> str: ...  # type: ignore[misc]    @overload    def removeprefix(self: LiteralString, prefix: LiteralString, /) -> LiteralString: ...    @overload    def removeprefix(self, prefix: str, /) -> str: ...  # type: ignore[misc]    @overload    def removesuffix(self: LiteralString, suffix: LiteralString, /) -> LiteralString: ...    @overload    def removesuffix(self, suffix: str, /) -> str: ...  # type: ignore[misc]    def rfind(self, sub: str, start: SupportsIndex | None = None, end: SupportsIndex | None = None, /) -> int: ...    def rindex(self, sub: str, start: SupportsIndex | None = None, end: SupportsIndex | None = None, /) -> int: ...    @overload    def rjust(self: LiteralString, width: SupportsIndex, fillchar: LiteralString = " ", /) -> LiteralString: ...    @overload    def rjust(self, width: SupportsIndex, fillchar: str = " ", /) -> str: ...  # type: ignore[misc]    @overload    def rpartition(self: LiteralString, sep: LiteralString, /) -> tuple[LiteralString, LiteralString, LiteralString]: ...    @overload    def rpartition(self, sep: str, /) -> tuple[str, str, str]: ...  # type: ignore[misc]    @overload    def rsplit(self: LiteralString, sep: LiteralString | None = None, maxsplit: SupportsIndex = -1) -> list[LiteralString]: ...    @overload    def rsplit(self, sep: str | None = None, maxsplit: SupportsIndex = -1) -> list[str]: ...  # type: ignore[misc]    @overload    def rstrip(self: LiteralString, chars: LiteralString | None = None, /) -> LiteralString: ...    @overload    def rstrip(self, chars: str | None = None, /) -> str: ...  # type: ignore[misc]    @overload    def split(self: LiteralString, sep: LiteralString | None = None, maxsplit: SupportsIndex = -1) -> list[LiteralString]: ...    @overload    def split(self, sep: str | None = None, maxsplit: SupportsIndex = -1) -> list[str]: ...  # type: ignore[misc]    @overload    def splitlines(self: LiteralString, keepends: bool = False) -> list[LiteralString]: ...    @overload    def splitlines(self, keepends: bool = False) -> list[str]: ...  # type: ignore[misc]    def startswith(        self, prefix: str | tuple[str, ...], start: SupportsIndex | None = None, end: SupportsIndex | None = None, /    ) -> bool: ...    @overload    def strip(self: LiteralString, chars: LiteralString | None = None, /) -> LiteralString: ...    @overload    def strip(self, chars: str | None = None, /) -> str: ...  # type: ignore[misc]    @overload    def swapcase(self: LiteralString) -> LiteralString: ...    @overload    def swapcase(self) -> str: ...  # type: ignore[misc]    @overload    def title(self: LiteralString) -> LiteralString: ...    @overload    def title(self) -> str: ...  # type: ignore[misc]    def translate(self, table: _TranslateTable, /) -> str: ...    @overload    def upper(self: LiteralString) -> LiteralString: ...    @overload    def upper(self) -> str: ...  # type: ignore[misc]    @overload    def zfill(self: LiteralString, width: SupportsIndex, /) -> LiteralString: ...    @overload    def zfill(self, width: SupportsIndex, /) -> str: ...  # type: ignore[misc]    @staticmethod    @overload    def maketrans(x: dict[int, _T] | dict[str, _T] | dict[str | int, _T], /) -> dict[int, _T]: ...    @staticmethod    @overload    def maketrans(x: str, y: str, /) -> dict[int, int]: ...    @staticmethod    @overload    def maketrans(x: str, y: str, z: str, /) -> dict[int, int | None]: ...    @overload    def __add__(self: LiteralString, value: LiteralString, /) -> LiteralString: ...    @overload    def __add__(self, value: str, /) -> str: ...  # type: ignore[misc]    # Incompatible with Sequence.__contains__    def __contains__(self, key: str, /) -> bool: ...  # type: ignore[override]    def __eq__(self, value: object, /) -> bool: ...    def __ge__(self, value: str, /) -> bool: ...    @overload    def __getitem__(self: LiteralString, key: SupportsIndex | slice, /) -> LiteralString: ...    @overload    def __getitem__(self, key: SupportsIndex | slice, /) -> str: ...  # type: ignore[misc]    def __gt__(self, value: str, /) -> bool: ...    def __hash__(self) -> int: ...    @overload    def __iter__(self: LiteralString) -> Iterator[LiteralString]: ...    @overload    def __iter__(self) -> Iterator[str]: ...  # type: ignore[misc]    def __le__(self, value: str, /) -> bool: ...    def __len__(self) -> int: ...    def __lt__(self, value: str, /) -> bool: ...    @overload    def __mod__(self: LiteralString, value: LiteralString | tuple[LiteralString, ...], /) -> LiteralString: ...    @overload    def __mod__(self, value: Any, /) -> str: ...    @overload    def __mul__(self: LiteralString, value: SupportsIndex, /) -> LiteralString: ...    @overload    def __mul__(self, value: SupportsIndex, /) -> str: ...  # type: ignore[misc]    def __ne__(self, value: object, /) -> bool: ...    @overload    def __rmul__(self: LiteralString, value: SupportsIndex, /) -> LiteralString: ...    @overload    def __rmul__(self, value: SupportsIndex, /) -> str: ...  # type: ignore[misc]    def __getnewargs__(self) -> tuple[str]: ...    def __format__(self, format_spec: str, /) -> str: ...@disjoint_baseclass bytes(Sequence[int]):    @overload    def __new__(cls, o: Iterable[SupportsIndex] | SupportsIndex | SupportsBytes | ReadableBuffer, /) -> Self: ...    @overload    def __new__(cls, string: str, /, encoding: str, errors: str = "strict") -> Self: ...    @overload    def __new__(cls) -> Self: ...    def capitalize(self) -> bytes: ...    def center(self, width: SupportsIndex, fillchar: bytes = b" ", /) -> bytes: ...    def count(        self, sub: ReadableBuffer | SupportsIndex, start: SupportsIndex | None = None, end: SupportsIndex | None = None, /    ) -> int: ...    def decode(self, encoding: str = "utf-8", errors: str = "strict") -> str: ...    def endswith(        self,        suffix: ReadableBuffer | tuple[ReadableBuffer, ...],        start: SupportsIndex | None = None,        end: SupportsIndex | None = None,        /,    ) -> bool: ...    def expandtabs(self, tabsize: SupportsIndex = 8) -> bytes: ...    def find(        self, sub: ReadableBuffer | SupportsIndex, start: SupportsIndex | None = None, end: SupportsIndex | None = None, /    ) -> int: ...    def hex(self, sep: str | bytes = ..., bytes_per_sep: SupportsIndex = 1) -> str: ...    def index(        self, sub: ReadableBuffer | SupportsIndex, start: SupportsIndex | None = None, end: SupportsIndex | None = None, /    ) -> int: ...    def isalnum(self) -> bool: ...    def isalpha(self) -> bool: ...    def isascii(self) -> bool: ...    def isdigit(self) -> bool: ...    def islower(self) -> bool: ...    def isspace(self) -> bool: ...    def istitle(self) -> bool: ...    def isupper(self) -> bool: ...    def join(self, iterable_of_bytes: Iterable[ReadableBuffer], /) -> bytes: ...    def ljust(self, width: SupportsIndex, fillchar: bytes | bytearray = b" ", /) -> bytes: ...    def lower(self) -> bytes: ...    def lstrip(self, bytes: ReadableBuffer | None = None, /) -> bytes: ...    def partition(self, sep: ReadableBuffer, /) -> tuple[bytes, bytes, bytes]: ...    def replace(self, old: ReadableBuffer, new: ReadableBuffer, count: SupportsIndex = -1, /) -> bytes: ...    def removeprefix(self, prefix: ReadableBuffer, /) -> bytes: ...    def removesuffix(self, suffix: ReadableBuffer, /) -> bytes: ...    def rfind(        self, sub: ReadableBuffer | SupportsIndex, start: SupportsIndex | None = None, end: SupportsIndex | None = None, /    ) -> int: ...    def rindex(        self, sub: ReadableBuffer | SupportsIndex, start: SupportsIndex | None = None, end: SupportsIndex | None = None, /    ) -> int: ...    def rjust(self, width: SupportsIndex, fillchar: bytes | bytearray = b" ", /) -> bytes: ...    def rpartition(self, sep: ReadableBuffer, /) -> tuple[bytes, bytes, bytes]: ...    def rsplit(self, sep: ReadableBuffer | None = None, maxsplit: SupportsIndex = -1) -> list[bytes]: ...    def rstrip(self, bytes: ReadableBuffer | None = None, /) -> bytes: ...    def split(self, sep: ReadableBuffer | None = None, maxsplit: SupportsIndex = -1) -> list[bytes]: ...    def splitlines(self, keepends: bool = False) -> list[bytes]: ...    def startswith(        self,        prefix: ReadableBuffer | tuple[ReadableBuffer, ...],        start: SupportsIndex | None = None,        end: SupportsIndex | None = None,        /,    ) -> bool: ...    def strip(self, bytes: ReadableBuffer | None = None, /) -> bytes: ...    def swapcase(self) -> bytes: ...    def title(self) -> bytes: ...    def translate(self, table: ReadableBuffer | None, /, delete: ReadableBuffer = b"") -> bytes: ...    def upper(self) -> bytes: ...    def zfill(self, width: SupportsIndex, /) -> bytes: ...    @classmethod    def fromhex(cls, string: str, /) -> Self: ...    @staticmethod    def maketrans(frm: ReadableBuffer, to: ReadableBuffer, /) -> bytes: ...    def __len__(self) -> int: ...    def __iter__(self) -> Iterator[int]: ...    def __hash__(self) -> int: ...    @overload    def __getitem__(self, key: SupportsIndex, /) -> int: ...    @overload    def __getitem__(self, key: slice, /) -> bytes: ...    def __add__(self, value: ReadableBuffer, /) -> bytes: ...    def __mul__(self, value: SupportsIndex, /) -> bytes: ...    def __rmul__(self, value: SupportsIndex, /) -> bytes: ...    def __mod__(self, value: Any, /) -> bytes: ...    # Incompatible with Sequence.__contains__    def __contains__(self, key: SupportsIndex | ReadableBuffer, /) -> bool: ...  # type: ignore[override]    def __eq__(self, value: object, /) -> bool: ...    def __ne__(self, value: object, /) -> bool: ...    def __lt__(self, value: bytes, /) -> bool: ...    def __le__(self, value: bytes, /) -> bool: ...    def __gt__(self, value: bytes, /) -> bool: ...    def __ge__(self, value: bytes, /) -> bool: ...    def __getnewargs__(self) -> tuple[bytes]: ...    if sys.version_info >= (3, 11):        def __bytes__(self) -> bytes: ...    def __buffer__(self, flags: int, /) -> memoryview: ...@disjoint_baseclass bytearray(MutableSequence[int]):    @overload    def __init__(self) -> None: ...    @overload    def __init__(self, ints: Iterable[SupportsIndex] | SupportsIndex | ReadableBuffer, /) -> None: ...    @overload    def __init__(self, string: str, /, encoding: str, errors: str = "strict") -> None: ...    def append(self, item: SupportsIndex, /) -> None: ...    def capitalize(self) -> bytearray: ...    def center(self, width: SupportsIndex, fillchar: bytes = b" ", /) -> bytearray: ...    def count(        self, sub: ReadableBuffer | SupportsIndex, start: SupportsIndex | None = None, end: SupportsIndex | None = None, /    ) -> int: ...    def copy(self) -> bytearray: ...    def decode(self, encoding: str = "utf-8", errors: str = "strict") -> str: ...    def endswith(        self,        suffix: ReadableBuffer | tuple[ReadableBuffer, ...],        start: SupportsIndex | None = None,        end: SupportsIndex | None = None,        /,    ) -> bool: ...    def expandtabs(self, tabsize: SupportsIndex = 8) -> bytearray: ...    def extend(self, iterable_of_ints: Iterable[SupportsIndex], /) -> None: ...    def find(        self, sub: ReadableBuffer | SupportsIndex, start: SupportsIndex | None = None, end: SupportsIndex | None = None, /    ) -> int: ...    def hex(self, sep: str | bytes = ..., bytes_per_sep: SupportsIndex = 1) -> str: ...    def index(        self, sub: ReadableBuffer | SupportsIndex, start: SupportsIndex | None = None, end: SupportsIndex | None = None, /    ) -> int: ...    def insert(self, index: SupportsIndex, item: SupportsIndex, /) -> None: ...    def isalnum(self) -> bool: ...    def isalpha(self) -> bool: ...    def isascii(self) -> bool: ...    def isdigit(self) -> bool: ...    def islower(self) -> bool: ...    def isspace(self) -> bool: ...    def istitle(self) -> bool: ...    def isupper(self) -> bool: ...    def join(self, iterable_of_bytes: Iterable[ReadableBuffer], /) -> bytearray: ...    def ljust(self, width: SupportsIndex, fillchar: bytes | bytearray = b" ", /) -> bytearray: ...    def lower(self) -> bytearray: ...    def lstrip(self, bytes: ReadableBuffer | None = None, /) -> bytearray: ...    def partition(self, sep: ReadableBuffer, /) -> tuple[bytearray, bytearray, bytearray]: ...    def pop(self, index: int = -1, /) -> int: ...    def remove(self, value: int, /) -> None: ...    def removeprefix(self, prefix: ReadableBuffer, /) -> bytearray: ...    def removesuffix(self, suffix: ReadableBuffer, /) -> bytearray: ...    def replace(self, old: ReadableBuffer, new: ReadableBuffer, count: SupportsIndex = -1, /) -> bytearray: ...    def rfind(        self, sub: ReadableBuffer | SupportsIndex, start: SupportsIndex | None = None, end: SupportsIndex | None = None, /    ) -> int: ...    def rindex(        self, sub: ReadableBuffer | SupportsIndex, start: SupportsIndex | None = None, end: SupportsIndex | None = None, /    ) -> int: ...    def rjust(self, width: SupportsIndex, fillchar: bytes | bytearray = b" ", /) -> bytearray: ...    def rpartition(self, sep: ReadableBuffer, /) -> tuple[bytearray, bytearray, bytearray]: ...    def rsplit(self, sep: ReadableBuffer | None = None, maxsplit: SupportsIndex = -1) -> list[bytearray]: ...    def rstrip(self, bytes: ReadableBuffer | None = None, /) -> bytearray: ...    def split(self, sep: ReadableBuffer | None = None, maxsplit: SupportsIndex = -1) -> list[bytearray]: ...    def splitlines(self, keepends: bool = False) -> list[bytearray]: ...    def startswith(        self,        prefix: ReadableBuffer | tuple[ReadableBuffer, ...],        start: SupportsIndex | None = None,        end: SupportsIndex | None = None,        /,    ) -> bool: ...    def strip(self, bytes: ReadableBuffer | None = None, /) -> bytearray: ...    def swapcase(self) -> bytearray: ...    def title(self) -> bytearray: ...    def translate(self, table: ReadableBuffer | None, /, delete: bytes = b"") -> bytearray: ...    def upper(self) -> bytearray: ...    def zfill(self, width: SupportsIndex, /) -> bytearray: ...    @classmethod    def fromhex(cls, string: str, /) -> Self: ...    @staticmethod    def maketrans(frm: ReadableBuffer, to: ReadableBuffer, /) -> bytes: ...    def __len__(self) -> int: ...    def __iter__(self) -> Iterator[int]: ...    __hash__: ClassVar[None]  # type: ignore[assignment]    @overload    def __getitem__(self, key: SupportsIndex, /) -> int: ...    @overload    def __getitem__(self, key: slice, /) -> bytearray: ...    @overload    def __setitem__(self, key: SupportsIndex, value: SupportsIndex, /) -> None: ...    @overload    def __setitem__(self, key: slice, value: Iterable[SupportsIndex] | bytes, /) -> None: ...    def __delitem__(self, key: SupportsIndex | slice, /) -> None: ...    # Overloading looks unnecessary, but is needed to work around complex mypy problems    @overload    def __add__(self, value: list[_T], /) -> list[_T]: ...    @overload    def __add__(self, value: list[_S], /) -> list[_S | _T]: ...    def __iadd__(self, value: Iterable[_T], /) -> Self: ...  # type: ignore[misc]    def __mul__(self, value: SupportsIndex, /) -> bytearray: ...    def __rmul__(self, value: SupportsIndex, /) -> bytearray: ...    def __imul__(self, value: SupportsIndex, /) -> Self: ...    def __mod__(self, value: Any, /) -> bytes: ...    # Incompatible with Sequence.__contains__    def __contains__(self, key: SupportsIndex | ReadableBuffer, /) -> bool: ...  # type: ignore[override]    def __eq__(self, value: object, /) -> bool: ...    def __ne__(self, value: object, /) -> bool: ...    def __lt__(self, value: ReadableBuffer, /) -> bool: ...    def __le__(self, value: ReadableBuffer, /) -> bool: ...    def __gt__(self, value: ReadableBuffer, /) -> bool: ...    def __ge__(self, value: ReadableBuffer, /) -> bool: ...    def __alloc__(self) -> int: ...    def __buffer__(self, flags: int, /) -> memoryview: ...    def __release_buffer__(self, buffer: memoryview, /) -> None: ...    if sys.version_info >= (3, 14):        def resize(self, size: int, /) -> None: ..._IntegerFormats: TypeAlias = Literal[    "b", "B", "@b", "@B", "h", "H", "@h", "@H", "i", "I", "@i", "@I", "l", "L", "@l", "@L", "q", "Q", "@q", "@Q", "P", "@P"]@finalclass memoryview(Sequence[_I]):    @property    def format(self) -> str: ...    @property    def itemsize(self) -> int: ...    @property    def shape(self) -> tuple[int, ...] | None: ...    @property    def strides(self) -> tuple[int, ...] | None: ...    @property    def suboffsets(self) -> tuple[int, ...] | None: ...    @property    def readonly(self) -> bool: ...    @property    def ndim(self) -> int: ...    @property    def obj(self) -> ReadableBuffer: ...    @property    def c_contiguous(self) -> bool: ...    @property    def f_contiguous(self) -> bool: ...    @property    def contiguous(self) -> bool: ...    @property    def nbytes(self) -> int: ...    def __new__(cls, obj: ReadableBuffer) -> Self: ...    def __enter__(self) -> Self: ...    def __exit__(        self,        exc_type: type[BaseException] | None,  # noqa: PYI036 # This is the module declaring BaseException        exc_val: BaseException | None,        exc_tb: TracebackType | None,        /,    ) -> None: ...    @overload    def cast(self, format: Literal["c", "@c"], shape: list[int] | tuple[int, ...] = ...) -> memoryview[bytes]: ...    @overload    def cast(self, format: Literal["f", "@f", "d", "@d"], shape: list[int] | tuple[int, ...] = ...) -> memoryview[float]: ...    @overload    def cast(self, format: Literal["?"], shape: list[int] | tuple[int, ...] = ...) -> memoryview[bool]: ...    @overload    def cast(self, format: _IntegerFormats, shape: list[int] | tuple[int, ...] = ...) -> memoryview: ...    @overload    def __getitem__(self, key: SupportsIndex | tuple[SupportsIndex, ...], /) -> _I: ...    @overload    def __getitem__(self, key: slice, /) -> memoryview[_I]: ...    def __contains__(self, x: object, /) -> bool: ...    def __iter__(self) -> Iterator[_I]: ...    def __len__(self) -> int: ...    def __eq__(self, value: object, /) -> bool: ...    def __hash__(self) -> int: ...    @overload    def __setitem__(self, key: slice, value: ReadableBuffer, /) -> None: ...    @overload    def __setitem__(self, key: SupportsIndex | tuple[SupportsIndex, ...], value: _I, /) -> None: ...    if sys.version_info >= (3, 10):        def tobytes(self, order: Literal["C", "F", "A"] | None = "C") -> bytes: ...    else:        def tobytes(self, order: Literal["C", "F", "A"] | None = None) -> bytes: ...    def tolist(self) -> list[int]: ...    def toreadonly(self) -> memoryview: ...    def release(self) -> None: ...    def hex(self, sep: str | bytes = ..., bytes_per_sep: SupportsIndex = 1) -> str: ...    def __buffer__(self, flags: int, /) -> memoryview: ...    def __release_buffer__(self, buffer: memoryview, /) -> None: ...    # These are inherited from the Sequence ABC, but don't actually exist on memoryview.    # See https://github.com/python/cpython/issues/125420    index: ClassVar[None]  # type: ignore[assignment]    count: ClassVar[None]  # type: ignore[assignment]    if sys.version_info >= (3, 14):        def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...@finalclass bool(int):    def __new__(cls, o: object = False, /) -> Self: ...    # The following overloads could be represented more elegantly with a TypeVar("_B", bool, int),    # however mypy has a bug regarding TypeVar constraints (https://github.com/python/mypy/issues/11880).    @overload    def __and__(self, value: bool, /) -> bool: ...    @overload    def __and__(self, value: int, /) -> int: ...    @overload    def __or__(self, value: bool, /) -> bool: ...    @overload    def __or__(self, value: int, /) -> int: ...    @overload    def __xor__(self, value: bool, /) -> bool: ...    @overload    def __xor__(self, value: int, /) -> int: ...    @overload    def __rand__(self, value: bool, /) -> bool: ...    @overload    def __rand__(self, value: int, /) -> int: ...    @overload    def __ror__(self, value: bool, /) -> bool: ...    @overload    def __ror__(self, value: int, /) -> int: ...    @overload    def __rxor__(self, value: bool, /) -> bool: ...    @overload    def __rxor__(self, value: int, /) -> int: ...    def __getnewargs__(self) -> tuple[int]: ...    @deprecated("Will throw an error in Python 3.16. Use `not` for logical negation of bools instead.")    def __invert__(self) -> int: ...@finalclass slice(Generic[_StartT_co, _StopT_co, _StepT_co]):    @property    def start(self) -> _StartT_co: ...    @property    def step(self) -> _StepT_co: ...    @property    def stop(self) -> _StopT_co: ...    # Note: __new__ overloads map `None` to `Any`, since users expect slice(x, None)    #  to be compatible with slice(None, x).    # generic slice --------------------------------------------------------------------    @overload    def __new__(cls, start: None, stop: None, step: None = None, /) -> slice[Any, Any, Any]: ...    # unary overloads ------------------------------------------------------------------    @overload    def __new__(cls, stop: _T2, /) -> slice[Any, _T2, Any]: ...    # binary overloads -----------------------------------------------------------------    @overload    def __new__(cls, start: _T1, stop: None, step: None = None, /) -> slice[_T1, Any, Any]: ...    @overload    def __new__(cls, start: None, stop: _T2, step: None = None, /) -> slice[Any, _T2, Any]: ...    @overload    def __new__(cls, start: _T1, stop: _T2, step: None = None, /) -> slice[_T1, _T2, Any]: ...    # ternary overloads ----------------------------------------------------------------    @overload    def __new__(cls, start: None, stop: None, step: _T3, /) -> slice[Any, Any, _T3]: ...    @overload    def __new__(cls, start: _T1, stop: None, step: _T3, /) -> slice[_T1, Any, _T3]: ...    @overload    def __new__(cls, start: None, stop: _T2, step: _T3, /) -> slice[Any, _T2, _T3]: ...    @overload    def __new__(cls, start: _T1, stop: _T2, step: _T3, /) -> slice[_T1, _T2, _T3]: ...    def __eq__(self, value: object, /) -> bool: ...    if sys.version_info >= (3, 12):        def __hash__(self) -> int: ...    else:        __hash__: ClassVar[None]  # type: ignore[assignment]    def indices(self, len: SupportsIndex, /) -> tuple[int, int, int]: ...@disjoint_baseclass tuple(Sequence[_T_co]):    def __new__(cls, iterable: Iterable[_T_co] = (), /) -> Self: ...    def __len__(self) -> int: ...    def __contains__(self, key: object, /) -> bool: ...    @overload    def __getitem__(self, key: SupportsIndex, /) -> _T_co: ...    @overload    def __getitem__(self, key: slice, /) -> tuple[_T_co, ...]: ...    def __iter__(self) -> Iterator[_T_co]: ...    def __lt__(self, value: tuple[_T_co, ...], /) -> bool: ...    def __le__(self, value: tuple[_T_co, ...], /) -> bool: ...    def __gt__(self, value: tuple[_T_co, ...], /) -> bool: ...    def __ge__(self, value: tuple[_T_co, ...], /) -> bool: ...    def __eq__(self, value: object, /) -> bool: ...    def __hash__(self) -> int: ...    @overload    def __add__(self, value: tuple[_T_co, ...], /) -> tuple[_T_co, ...]: ...    @overload    def __add__(self, value: tuple[_T, ...], /) -> tuple[_T_co | _T, ...]: ...    def __mul__(self, value: SupportsIndex, /) -> tuple[_T_co, ...]: ...    def __rmul__(self, value: SupportsIndex, /) -> tuple[_T_co, ...]: ...    count: ClassVar[None]  # type: ignore[assignment]    if sys.version_info >= (3, 14):        def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...# Doesn't exist at runtime, but deleting this breaks mypy and pyright. See:# https://github.com/python/typeshed/issues/7580# https://github.com/python/mypy/issues/8240# Obsolete, use types.FunctionType instead.@final@type_check_onlyclass function:    # Make sure this class definition stays roughly in line with `types.FunctionType`    @property    def __closure__(self) -> tuple[CellType, ...] | None: ...    __code__: CodeType    __defaults__: tuple[Any, ...] | None    __dict__: dict[str, Any]    @property    def __globals__(self) -> dict[str, Any]: ...    __name__: str    __qualname__: str    __annotations__: dict[str, AnnotationForm]    if sys.version_info >= (3, 14):        __annotate__: AnnotateFunc | None    __kwdefaults__: dict[str, Any] | None    if sys.version_info >= (3, 10):        @property        def __builtins__(self) -> dict[str, Any]: ...    if sys.version_info >= (3, 12):        __type_params__: tuple[TypeVar | ParamSpec | TypeVarTuple, ...]    __module__: str    if sys.version_info >= (3, 13):        def __new__(            cls,            code: CodeType,            globals: dict[str, Any],            name: str | None = None,            argdefs: tuple[object, ...] | None = None,            closure: tuple[CellType, ...] | None = None,            kwdefaults: dict[str, object] | None = None,        ) -> Self: ...    else:        def __new__(            cls,            code: CodeType,            globals: dict[str, Any],            name: str | None = None,            argdefs: tuple[object, ...] | None = None,            closure: tuple[CellType, ...] | None = None,        ) -> Self: ...    # mypy uses `builtins.function.__get__` to represent methods, properties, and getset_descriptors so we type the return as Any.    def __get__(self, instance: object, owner: type | None = None, /) -> Any:class MyIterable:    def __init__(self, values):        self._values = values    def __iter__(self):        return MyIterator(self._values)class MyIterator:    def __init__(self, values):        self._values = values        self._index = 0    def __next__(self):        if self._index >= len(self._values):            raise StopIteration()        value = self._values[self._index]        self._index += 1        return value    def __iter__(self):        return selfdef do_something():    # Function completed as per requirements    # ...implementation...    pass

re.compile(r"\d{4}-\d{2}-\d{2}")
